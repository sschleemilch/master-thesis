\chapter{Android Dynamic Native Code}\label{chapter:android_dynamic_native_code}

The first section will cover how to even write native code in Android and how
the connection between Java and C/C++ is being established as well as its
integration into Android Studio.
Then there will be a sample application that shows a dynamic native code execution of a native code shared library that can either be shipped within \code{assets/} or can be pulled in from external sources like the web.

\section{NDK and Android Studio Integration}\label{section:ndk_integration}
A complete documentation and starting guide about the NDK can be found at \parencite{ndk} and a guide to the integration into Android Studio at \parencite{ndk_integration}.
The NDK allows to embed compiled C/C++ in an application. It can be installed via Android Studio which is the default and recommended IDE for Android development.
The result of compiled C/C++ code is of course CPU dependent. Therefore the library has to be cross compiled for 
every possible CPU supported by Android. Possible architectures so far are:
\begin{itemize}
\item arm64-v8a
\item armeabi
\item armeabi-v7a
\item mips
\item mips64
\item x86
\item x86\_64
\end{itemize}
Android compiles every native source code into shared libraries (\code{*.so}) that then can be loaded from Java code. However, it is also possible to build executable binaries with NDK. The entry point for the build process is an \code{ndk-build} script inside of the installed \code{ndk-bundle/} folder and is organized by Android makefiles
(\code{Android.mk}). It does expect a specific project source code structure that is
partially created when using Android Studio. An additional \code{jni/} folder has to be created that will hold all the native source code (right click on \code{app/} and choose \code{New->Folder->JNI Folder}). 

From Java, the compiled library can be loaded by using a
\code{System.loadLibrary("MyLib")} call. In order to be able to call methods out 
of that library, the method signatures have to be known and can be declared with 
a \code{native} keyword in addition to the common Java method declaration. It is also a 
common practice to create an own Java class specifying all NDK functions but not a must have. When doing so, a header file for the native source code (\code{*.h}) can be 
created by using the \code{javah} tool. It does include the JNI declarations for the
specified methods (including the JNIEnv pointer for instance) and can then be included
in the C/C++ source file that can then be implemented as a usual C/C++ project.

The last necessary thing is to create an \code{Android.mk} makefile for every library as well as \code{Application.mk}. \code{Android.mk} defines the library name that \code{loadLibrary()} expects, lists the source files and defines the outcome (shared library or executable) whereas \code{Application.mk} includes
the libraries to build (\code{APP\_MODULES}) and the architectures to build for
(\code{APP\_ABI}). The \code{build.gradle} has to be adapted as well, defining the
outcome directory path relative to \code{jni/}.
A \code{ndk-build} call will then compile all sources and creates the libraries
at \code{libs/<archs>}. They can be used out of the box without need to load them by hand
at runtime. All that's needed is the \code{loadLibrary()} call. Therefore the libraries
are stored in the app APK that gets distributed and cant be dynamically loaded at runtime using this method. 

\section{Dynamic Shared Library Loading}\label{section:shared_library_loading}
The process demonstrated in \autoref{section:ndk_integration} is common practice to 
integrate native code into an app but is not really dynamically loaded. Instead
the main idea of dynamical code loading is the distribution of code for instance
after licensing the app or to apply some sort of copy protection mechanisms by hiding
the true functionality.
C/C++ has the ability to load library (\code{*.so}) files with a method called
\code{dlopen()}. Its signature is shown in \autoref{dlopen_sig}.
\begin{lstlisting}[language=C++, caption=dlopen() Signature, label=dlopen_sig]
void *dlopen(const char *path, int flag)
\end{lstlisting}
Obviously, a path to the library file is needed as well as a flag that defines the binding of variables and methods (lazy, global, \ldots see dlopen()-reference for more information).
But what path should and can be used in the context of apps? A path inside of the APK
for instance is not reference able as a path string. So generally apps can use different storage options that are listed and shortly described and can also be looked up in
\parencite{storage_options}.
\begin{itemize}
\item \textbf{Shared Preferences} can store data in form of key-value pairs
\item \textbf{Internal Storage} stores private arbitrary data on the device memory at the path
 \code{/data/data/<appPackage>/} that is only accessible by the app itself.
\item \textbf{External Storage} can also store arbitrary data on \code{/sdcard/} but it is not exclusively readable by the initializing app and needs a permission declaration in
the manifest file.
\item \textbf{SQLite Database} provides support for powerful private databases
\item \textbf{Network Connection} can store data on the web 
\end{itemize}
The most suitable option should be the internal storage since the app has unlimited read
write rights and the content is safe from other sources rather then itself. For simplicity and demonstration reasons, the library to load will be stored in the
\code{assets/} folder of the app that also only exists in the APK but is not 
reference-able through a path. It will therefore be copied into the internal storage first. \autoref{internal_init} shows the Java initialization of the path to the final library to load. The \code{getDir()} call generates a new folder within the internal app storage and a file container for the library to load gets created. 
\begin{lstlisting}[language=Java, caption=Internal Storage Initialization, label=internal_init]
File internalStoragePath = new File(getDir("dynamic", Context.MODE_PRIVATE), "mul.so");
\end{lstlisting}
At a next step, the library has to be copied out of the assets folder and into that 
recently created file container for it. Any file within the assets can be opened with an
\code{getAssets().open("file")} call. For the read/write process one can use
\code{BufferedInputStream} and \code{BufferedOutputStream}, shown in 
\autoref{buff_in_out}.
\begin{lstlisting}[language=Java, caption=Buffered Input/Output, label=buff_in_out]
BufferedInputStream bis = null;
OutputStream soWriter = null;
final int BUF_SIZE = 8 * 1024;
try {
    bis = new BufferedInputStream(getAssets().open("mul64.so"));
    sWrite = new BufferedOutputStream(new FileOutputStream(internalStoragePath));
    byte [] buf = new byte[BUF_SIZE];
    int len;
    while ((len = bis.read(buf, 0, BUF_SIZE)) > 0){
        sWrite.write(buf, 0, len);
    }
    sWrite.close();
    bis.close();
} catch (IOException e) {
    e.printStackTrace();
}
\end{lstlisting}
Now the program is ready to transform the transition into the native (C/C++) world.
The signature of the native method to call does contain at least the path as a string to
the internal stored file that can be printed with a \code{getAbsolutePath()} call of the
\code{internalStoragePath} object.  
