\chapter{Fundamentals/Basics}\label{chapter:android_basics}

\section{Android Architecture}\label{section:android_architecture}
To provide copy protection mechanisms for Android Apps,
of course a deep understanding of the Android system itself
is necessary or at least helpful.
Android is built on the Linux kernel. Android does provide not
only shell binaries (Linux kernel) but also a GUI environment
as well as predefined frameworks and a complete environment
for developers to write Apps in the Java programming language.
That's why Android is considered to be a ``full software stack''
\parencite[p.7f]{levin}. Although it's built on Linux,
Google did modify the Linux kernel to their need.
As a result, the Android kernel differs
incompatibly with the Linux kernel since version 2.6.27.

The difference at kernel-level is not massive compared to
the differences at user-mode where Android does have entirely new
components, namely:

\begin{itemize}
\item Dalvik Runtime including the Dalvik Virtual Machine (DVM)
respectively the Android Runtime (ART) since Android version > 5.0.
\item The Bionic C-Library instead of the GNU C Library (GlibC)
\item Hardware Abstraction Layer (HAL)
\item Java Native Interface (JNI)
\item Android specific frameworks
\end{itemize}

\autoref{fig:androidvslinux} visually summarizes the difference
between Android and Linux.

\begin{figure}[htb]
  \includegraphics[width=\textwidth]{figures/androidvslinux}
  \caption[Android vs Linux]{Android and Linux comparison taken from
  ~\parencite[p.9]{levin}}
  \label{fig:androidvslinux}
\end{figure}

The Android specific frameworks are the core work that makes Android
special. They simplify the creation process of applications massively.
Developers can use the higher level language Java rather than developing
in C/C++. Additionally, there is a rich set of APIs to solve most of
programmers everyday problems.

In order to get Java programs run on Android, the DVM is introduced
which is quite similar to a Java Virtual Machine (JVM) but more simple (since
mobile devices have limited computing power, especially in their early days).
The DVM provides an interface between the operating system and
the Java application world, after all the execution of Java written programs.
The difference between the DVM and JVM is the alternative form of bytecode
which gets executed in the VM. Another difference is that Dalvik is
register-based in contrast to JVM's stack based architecture.
DVM is optimized for mobile devices
in terms of efficiency and sharing memory and is using the
Dalvik Executable format (DEX) as bytecode which is device
independent and one reason for choosing a VM design in the first place \parencite[p.11f]{levin}. These \code{.dex} files are being
packed into Java libraries (JAR) or into Android Application Packages (APK)
and will get created automatically by the official Android Studio IDE from Google out of Java code.

A runtime's purpose in general is to provide
interpretation of machine independent code, in other words,
transforming Java byte-code into machine-code (pure 1's and 0's a CPU understands).
With Android version 5.0, Google did introduce ART which is an
alternative runtime. Like Dalvik it does use a VM but with a
different compile timing concept.
The prior Dalvik runtime does use Just-In-Time (JIT) compiling
where executable machine code is created not until the App runtime.
ART on the other hand does use Ahead-Of-Time (AOT) compilation
which compiles an App to machine code at installation time.
The reason for JIT in the first place were among other things
storage limitations of mobile devices at the time Android was released
\parencite[p.11f]{levin}. As a result, the ART Apps installation time
is increased as well as the required storage space as a trade-off
to the App startup and runtime performance.

The JNI provides an opportunity to write Java programs with embedded
native processor specific code to escape from the VM world to for
instance access hardware directly.
It is mostly used to optimize the performance for Apps (e.g. games)
or to impede reverse engineering of the application code.
Google does provide a Native Development Kit (NDK) to help
developers creating native libraries ~\parencite{ndk} that includes
cross compiling tool-chains for all supported Android architectures.
The officially supported language for the NDK is C/C++.

Bionic is the Android corresponding GlibC library which was created
for license and simplicity reasons. Overall, it is more lightweight
than the GlibC and well adapted for Android's needs.

Since Android is likely to run on a great variety of devices,
it has to support a big amount of different hardware versions.
The HAL addresses this problem and
standardizes the interface by allowing hardware vendors
to implement their own drivers \parencite[p.18f]{levin}. It helps
developers to use the same programming interface to hardware even when the
device architecture and hardware components do differ. 

\section{Android Apps}\label{section:android_apps}
Apps are the most abstract level of the Android software stack.
Generally there are either system-(mostly pre-installed, like a browser)
or user-apps (everything installed by user).
The system Apps storage location (\code{/system/apps/}) differs from
the user Apps (\code{/data/apps/}). System Apps are included into the
distributed OS whereas user-apps can be installed and updated
via the Android Debug Bridge (ADB), App stores
like the Google Play Store or directly on the device by opening
downloaded App files (APKs). The most common way for consumers is 
downloading/installing Apps via an App Store. 

Every App has its own sand-boxed environment. That means that
Apps can not access data from other Apps and they can only access
resources those permissions were granted during installation time.
These are one of the basic Android security concepts,
the Privilege separation and the principle of the least
privileges \parencite[ch.1]{securityinternals} which can be applied through
Linux group and user permission concepts.

Apps do have several components, the main ones are:

\begin{itemize}
\item Activities
\item Services
\item Content Providers
\item Broadcast Receivers
\end{itemize}

Activities do represent a screen view in the UI ready for user
interaction. They can be started independently even though one Activity
is chosen to be the one that starts when the user clicks on the
App icon. Services are purely functional and are not represented
at the UI compared to Activities. Their utilization are mostly time
consuming operations in the background of an App like server
communication or computational tasks. Since Apps are sand-boxed,
they can't access each others data which can be seen as a limitation
if Apps should be able to communicate with each other.
That's why Content Providers do offer an interface to the App
data which is chosen to be exchanged.
They use a lower level Inter Process Communication (IPC) protocol
provided by the Android Stack which, like the name indicates, operates
on process level in Linux.
With Broadcast Receivers, an App can react on system-wide events
(broadcasts) \parencite[ch.1]{securityinternals}.

Apps are distributed in form of machine independent \code{.apk} files.
The APK file is a file container and is an extension to
JAR which is in turn an extension to the ZIP file format.
Thus the content of the APK can be extracted with standard ZIP
compression tools \parencite{securityinternals}.

\autoref{fig:apk_content_tree} lists the content of an APK container
after extraction.
%\begin{figure}[htb]
%  \includegraphics[width=\textwidth]{figures/apk_content}
%  \caption[APK Content]{Contents of the APK file}
%  \label{fig:apk_content}
%\end{figure}

\begin{figure}[htb]
  \dirtree{%
.1 apk/ (=.jar = .zip).
.2 AndroidManifest.xml.
.2 res/.
.3 anim/.
.3 color/.
.3 drawable/.
.3 layout/.
.3 menu/.
.3 raw/.
.3 xml/.
.2 resources.arsc.
.2 lib/.
.3 armeabi/.
.3 armeabi-v7a/.
.3 x86/.
.3 ...
.2 classes.dex.
.2 META-INF/.
.3 CERT.RSA.
.3 CERT.SF.
.3 MANIFEST.MF
.2 assets/.
}
\caption[APK Content Tree]{APK Content Tree}
\label{fig:apk_content_tree}
\end{figure}

The \code{AndroidManifest.xml} file holds meta-data information
about the App like the package name, it's version, a list of
activities (one of them is marked as the action \code{MAIN} activity) and required permissions. \code{resources.arsc}
does contain precompiled resources like strings, styles
or binary XML. Developers can use the \code{assets/} folder
to store raw data needed for the App like music files,
fonts, additional DEX files and every other arbitrary file.
If the App does make use of the JNI,
the \code{lib/} folder does contain compiled library directories
for every supported CPU architecture (armeabi, x86, \ldots).
Every resource which is directly addressed from Android code
is stored in the \code{res/} folder including XML files for
layouts and menus. The \code{META-INF/} directory does hold
the signatures for the specific App similar to a JAR file.
The heart of every App is the \code{classes.dex} that does
contain the application code in form of the machine independent
DEX format specified by Google \parencite{dex} which is comparable to
Java byte code. The Java Development
Kit (JDK) tool ``javac'' creates a JAR out of every inputted
 \code{.java} file while the Google build tool ``dx'' takes over
 the transition from \code{.jar} to \code{.dex} ~\parencite{dxtool}.
 An \code{ApkBuilder} takes the DEX file, adding \code{.so} files and
 other resources and finally building the \code{base.apk} that gets signed
 afterwards by the \code{jarsigner}.

\section{App Installation Process}\label{section:app_installation}
As in \autoref{section:android_apps} described, Apps are distributed
in form of APK files. This chapter describes what happens next to
the APK file.

The APK file gets forwarded to the Android ``Package Manager''(pm)
which then calls the \code{installPackage()} method for this
APK. Among other things, the pm copies the original \code{*.apk}
to the path \code{/data/app/<package>.<appname>-1/base.apk}.
This location is used and accessed in order to get the
needed resources for the App to run (layout, drawables, \ldots).
The \code{lib/} directory is getting extracted and gets also copied
into that path. \code{classes.dex} gets optimized by either ``dexopt''
or ``dex2oat'' depending which runtime is present (DVM or ART).
The outcoming file is in both cases no more machine independent
and lies at \code{/data/dalvik-cache/<arch>/} with the name
\code{data@app@<packagename>.<appname>-1@base.apk@classes.dex}.
That path however did change with Android version 6 to
\code{/data/app/oat/<pachagename>.<appname>/<arch>/base.odex} which
is more straight forward since every the whole data of an App is being
stored at the same place (except for the internal storage an App can
use, which is located at \code{/data/data/...}).
It does represent the last stored unit of an App that then
gets executed in the next step.
Attention should be paid to the file extension.
It's the same (\code{.dex}) with both runtimes but is actually a totally
different file format.
Therefore the name of the file is just a reference to the path
of its source when replacing the ``@'' characters with ``/'' (prior Android 6).
Since Android 6, it became a little more convenient since the file extension changed to ``\code{.odex}'' which corresponds to its actual content since it is
an optimized version of the DEX.
If the present runtime is DVM, thus Android < 5.0, the generated
file format is ODEX (Optimized DEX) and in later versions
ELF 32/64 (Executable Linking Format) although the responsible
tool for that conversion step is called ``dex2oat''. Still, the file
is named the same way and won't change to ``\code{.elf}'' so the naming
convention is more like a semantic information rather than saying something
about its content explicitly.
This ELF file also gets analyzed in the course of this thesis
(it does however hold an ``OAT'' file among other things so that
the tool name actually does makes sense).
To give an App the possibility to
store some data, a \code{/data/data/<appname>} directory is
also created which is a storage whose permissions are limited to its owning
App.

Last but not least, the pm adds entries to the
\code{/data/system/packages.xml} as well as the
\code{/data/system/packages.list} files. They do contain
meta information about the installed packages like
required permissions and the UID/GID of that instance.
Android uses that UID/GID to enforce the sandboxing model
~\parencite[ch.1]{securityinternals}.
\autoref{fig:app_installation} shows the explained
relevant actions the pm performs.

\begin{figure}[htb]
  \includegraphics[width=\textwidth]{figures/app_installation}
  \caption[App installation process]{App installation process}
  \label{fig:app_installation}
\end{figure}

\section{App Execution Process}\label{section:app_execution_simple}
This chapter is supposed to give a short introduction about the
main concept of the App execution process without going into
great detail about it. However, the detailed inspection will
be performed in \autoref{section:app_execution_detail}.
When describing the execution process of an App, again the
runtime must be considered (Dalvik or ART) since the execution process
obviously differs. In both cases the entry-point of the App is the
file stored at \code{/data/dalvik-cache/...@classes.dex} like in
\autoref{section:app_installation} described (Again differs depending on the Android version).
``Zygote'' is
the name of one of the first processes Android starts when booting.
The process is responsible for loading more services and libraries
of the Android framework and does hold precompiled resources that
nearly every App instance will need.
By starting an App, it's therefore much more efficient to fork
the Zygote process at Linux layer and then including the App specific part
rather than  creating a whole new process for every App.
This will also be introduced in greater detail \parencite[ch.2]{hackershandbook}.

\subsection{Dalvik}
As in section \autoref{section:app_installation} described, an
ODEX file is created at first startup of an App. Even though
the pure DEX file is runnable in the DVM, it still gets optimized
into ODEX to get the most performance out of the
constraints of a VM.
It then gets processed by the actual Dalvik runtime to produce
native code (machine code) that in the end is executable by the CPU (JIT).
This native code additionally must be linked with libraries of the App
(\code{/data/app/<pkg>.<name>-1/lib/*.so}) implemented via the JNI
and also with Android framework libraries to result in a complete
executable that can be executed by the CPU. It does however
reference resources out of the corresponding \code{base.apk} file (layouts,
drawables, assets, \ldots). The execution process is also painted
at \autoref{fig:app_execution}.

\subsection{ART}
The difference of ART in comparison to Dalvik is the missing
JIT compiling step since ART does that at installation time
(AOT). Therefore the ELF file does contain the executable that
only needs to be extracted by the ART followed by the same
linking steps that Dalvik does after JIT. \autoref{fig:app_execution}
shows the direct comparison of those two runtimes.

\begin{figure}[htb]
  \includegraphics[width=\textwidth]{figures/app_execution}
  \caption[App execution process]{App execution process}
  \label{fig:app_execution}
\end{figure}
