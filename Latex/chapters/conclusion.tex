\chapter{Conclusion}\label{chapter:conclusion}
The runtime transition from the Android specialized virtual machine (Dalvik VM)
to the Android Runtime ART introduced as an option in Android 4.3 did not change the difficulty of reverse code engineering Android Apps. So they are in general still just as vulnerable to patching/theft and code injection as they were before.
However, internal mechanisms of ART do change the feasibility of copy protection
mechanisms based on byte code interpreted by the virtual machine like hiding
whole methods in the DEX format or Junk-Byte-Insertion. 
Since Apps still are distributed via the DEX
format, it is still very present under ART. What did change, is the optimization
step that now produces an ELF file with AOT compilation compared to the optimized
DEX (ODEX) that relied on a JIT concept. Although ELFs are normally runnable by 
themselves or are getting linked in another executable, the invocation of methods still happens through DEX. 
Dynamic obfuscation techniques regarding DEX files are still applicable although
it has to keep in mind that there is a conversion step in between loading that 
file and the actual execution that could lead to performance issues depending 
on the file size. The possibility of using C/C++ via the Android NDK is a 
powerful tool of dynamically modify the own code or loading additional
content. Shared object loading out of a file can be accomplished using Java or 
the NDK as well as executing an external binary. For security reasons it
would be interesting to dynamically load code directly out of memory instead
of writing to a file first. It is possible in general since memory can be allocated by the App as well as marking it as executable. Like shown, it
therefore can be used to execute machine code directly. Instead invoking 
whole file formats is more complex since linker functionalities are missing
and needs to be implemented on its own. An idea did rise that was made of 
distributing only native code instead of the reverse code prune DEX format
but did collapse due to missing rights predominantly. 
The NDK can overall do a great contribution to copy protection mechanisms
by improving licensing concepts to make the license check mandatory to get 
an App to work. Content like shown as an example with strings can be 
encrypted and decrypted afterwards with a key fetched inside of that
license call. Trusted execution environments are a great idea that lacks 
in terms of usability for everyday developers but could be used for instance
to make a safe license call or stream content out of it if the developer 
has access to even writing trusted Apps. 
So to achieve a secure copy protection mechanism, individual solutions
using dynamic code or encrypting content are promising as long as the 
corresponding key fetching mechanisms as well as the storage is chosen wisely.
It has to keep also in mind that obfuscation techniques especially those that 
are dynamically loading code can be abused also by malware to hide its true
intention from static malware analysis tools.

\section{Future Work}\label{section:future_work}
To provide a secure copy protection mechanism, of course some more work has to
be done. It could be analyzed in even more great detail than described in \autoref{section:art_internals} how the method invocation of ELF methods into
the forked Zygote process works. It may reveal new possibilities of circumventing
the DEX format or sparing out crucial parts that are not needed. Possibilities
of dynamic native code shown here are proof of concepts and would need to be
used adequately. Especially there can be more clever techniques regarding 
the licensing mechanism itself using cross-interlocking of native and Java code.
Also asymmetric encryption as well as key handling needs more investigation.
A promising future work could include loading common files
like executables right into memory and executing them. That would introduce 
a new layer of complexity from an attackers perspective since there won't be
any files residing on the file-system. Regarding the security of Java calls 
compared to Java calls through the JNI needs also an evaluation. 
